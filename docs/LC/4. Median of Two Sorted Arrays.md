# Approach 1: Merge and Sort

pseudocode:
- new sorted list = list 1 + list 2
- declare length and mid = length // 2
- if length is odd return mid element
- elif return average  = (new_list[mid- 1] + new_list[mid]) /2.0
- Time Complexity: (m + n) log (m+n)
- Space: m + n

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        # Combine the two arrays into one and sort it
        new_list = sorted(nums1 + nums2)
        
        # Calculate the length and the middle index
        length = len(new_list)
        mid = length // 2
        
        # If the length is odd, return the middle element
        if length % 2 != 0:
            return new_list[mid]
        # If the length is even, return the average of the two middle elements
        else:
            return (new_list[mid - 1] + new_list[mid]) / 2.0

```

# Approach 2: Two-Pointer Method

pseudocode:
- **Input**: Two sorted arrays `nums1` and `nums2`.
- **Pointers**: Initialize `i` and `j` to 0 to iterate over both arrays.
- **Loop**: Iterate through both arrays until we reach the middle of the combined arrays.
- **Median Calculation**: Keep track of two middle values (`median1` and `median2`). On each step, pick the smaller element from either array and move the respective pointer forward.
- **Odd or Even Length**:
    - If the total length is odd, return `median1` as the middle element.
    - If the total length is even, return the average of `median1` and `median2` as the final median.
- TC: (N + M) /2
- SC: O(1)


```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        len1, len2 = len(nums1), len(nums2)  # Lengths of the input arrays
        i, j = 0, 0  # Pointers to iterate over nums1 and nums2
        median1, median2 = 0, 0  # To store the two middle values

        # Loop until we reach the middle of the combined arrays
        for count in range((len1 + len2) // 2 + 1):
            median2 = median1  # Store the previous median value
            if i < len1 and (j >= len2 or nums1[i] <= nums2[j]):
                # If nums1 has remaining elements and the current element in nums1 is smaller
                median1 = nums1[i]
                i += 1
            else:
                # If nums2 has remaining elements and the current element in nums2 is smaller
                median1 = nums2[j]
                j += 1

        # If the combined length is odd, return the single middle element
        if (len1 + len2) % 2 == 1:
            return float(median1)
        # If the combined length is even, return the average of the two middle elements
        else:
            return (median1 + median2) / 2.0

```

# Approach 3: # Code for Binary Search

